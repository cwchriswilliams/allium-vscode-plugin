const HOVER_DOCS: Record<string, string> = {
  entity: "Defines a persisted domain concept with fields and derived values.",
  rule: "Defines a behavior: trigger (`when`), preconditions (`requires`), and outcomes (`ensures`).",
  when: "Trigger clause that starts a rule.",
  requires: "Precondition clause that must hold before a rule can apply.",
  ensures: "Outcome clause that must hold after a rule applies.",
  config:
    "Declares reusable configuration values referenced as `config.<key>`.",
  surface:
    "Defines an actor-facing projection with context, exposed fields, and capabilities.",
  actor: "Defines a principal interacting with one or more surfaces.",
  open_question:
    "Marks unresolved product or domain questions inside the specification.",
  deferred: "Declares behavior that is intentionally deferred to another spec.",
};

export function hoverTextAtOffset(text: string, offset: number): string | null {
  const token = tokenAtOffset(text, offset);
  if (!token) {
    return null;
  }

  return HOVER_DOCS[token] ?? null;
}

export function findLeadingDocComment(
  text: string,
  declarationStartOffset: number,
): string | null {
  const lineStart = text.lastIndexOf("\n", declarationStartOffset - 1) + 1;
  let cursor = lineStart - 1;
  const commentLines: string[] = [];

  while (cursor >= 0) {
    const previousLineEnd = cursor;
    const previousLineStart = text.lastIndexOf("\n", previousLineEnd - 1) + 1;
    const line = text.slice(previousLineStart, previousLineEnd).trimEnd();
    if (line.trim().length === 0) {
      if (commentLines.length === 0) {
        cursor = previousLineStart - 1;
        continue;
      }
      break;
    }
    if (!/^\s*--/.test(line)) {
      break;
    }
    commentLines.push(line.replace(/^\s*--\s?/, ""));
    cursor = previousLineStart - 1;
  }

  if (commentLines.length === 0) {
    return null;
  }
  return commentLines.reverse().join("\n").trim();
}

function tokenAtOffset(text: string, offset: number): string | null {
  if (offset < 0 || offset >= text.length) {
    return null;
  }

  const isIdent = (char: string | undefined): boolean =>
    !!char && /[A-Za-z_]/.test(char);
  let start = offset;
  while (start > 0 && isIdent(text[start - 1])) {
    start -= 1;
  }

  let end = offset;
  while (end < text.length && isIdent(text[end])) {
    end += 1;
  }

  if (start === end) {
    return null;
  }
  return text.slice(start, end);
}
