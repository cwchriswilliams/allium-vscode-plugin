#!/usr/bin/env node
import * as fs from "node:fs";
import * as path from "node:path";

type DiagramFormat = "d2" | "mermaid";
type DiagramNodeKind =
  | "entity"
  | "value"
  | "variant"
  | "rule"
  | "surface"
  | "actor"
  | "enum"
  | "trigger";
type SplitMode = "module";

interface DiagramNode {
  id: string;
  key: string;
  label: string;
  kind: DiagramNodeKind;
}

interface DiagramEdge {
  from: string;
  to: string;
  label: string;
}

interface DiagramModel {
  nodes: DiagramNode[];
  edges: DiagramEdge[];
}

interface DiagramIssue {
  code: "allium.diagram.skippedDeclaration";
  message: string;
  line: number;
}

interface DiagramBuildResult {
  model: DiagramModel;
  issues: DiagramIssue[];
  modules: string[];
}

interface DiagramFilterOptions {
  focusNames?: string[];
  kinds?: DiagramNodeKind[];
}

interface ParsedArgs {
  format: DiagramFormat;
  outputPath?: string;
  strict: boolean;
  reverseLinks: boolean;
  constraintLabels: boolean;
  split?: SplitMode;
  filters: DiagramFilterOptions;
  inputs: string[];
}

function main(argv: string[]): number {
  const parsed = parseArgs(argv);
  if (!parsed) {
    return 2;
  }

  const files = resolveInputs(parsed.inputs);
  if (files.length === 0) {
    process.stderr.write("No .allium files found for the provided inputs.\n");
    return 2;
  }

  const diagramResults = files.map((filePath) => {
    const text = fs.readFileSync(filePath, "utf8");
    return { filePath, result: buildDiagramResult(text) };
  });

  const issueCount = writeIssues(diagramResults);
  if (parsed.strict && issueCount > 0) {
    process.stderr.write(
      "Diagram extraction produced skipped declaration findings in strict mode.\n",
    );
    return 1;
  }

  if (parsed.split === "module") {
    if (!parsed.outputPath) {
      process.stderr.write(
        "Expected --output <directory> when using --split module.\n",
      );
      return 2;
    }
    writeSplitByModule(diagramResults, parsed);
    return 0;
  }

  const combined = mergeModels(
    diagramResults.map((entry) => entry.result.model),
  );
  const augmented = augmentDiagramModel(combined, diagramResults, parsed);
  const filtered = applyDiagramFilters(augmented, parsed.filters);
  const output = renderDiagram(filtered, parsed.format);
  if (parsed.outputPath) {
    const fullPath = path.resolve(process.cwd(), parsed.outputPath);
    fs.mkdirSync(path.dirname(fullPath), { recursive: true });
    fs.writeFileSync(fullPath, output, "utf8");
    process.stdout.write(
      `Wrote ${parsed.format} diagram to ${parsed.outputPath}\n`,
    );
  } else {
    process.stdout.write(output);
  }

  return 0;
}

function parseArgs(argv: string[]): ParsedArgs | null {
  let format: DiagramFormat = "d2";
  let outputPath: string | undefined;
  let strict = false;
  let reverseLinks = false;
  let constraintLabels = false;
  let split: SplitMode | undefined;
  const focusNames: string[] = [];
  const kinds: DiagramNodeKind[] = [];
  const inputs: string[] = [];

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    if (arg === "--format") {
      const formatArg = argv[i + 1];
      if (formatArg !== "d2" && formatArg !== "mermaid") {
        printUsage("Expected --format d2|mermaid");
        return null;
      }
      format = formatArg;
      i += 1;
      continue;
    }
    if (arg === "--output") {
      const outArg = argv[i + 1];
      if (!outArg) {
        printUsage("Expected a path after --output");
        return null;
      }
      outputPath = outArg;
      i += 1;
      continue;
    }
    if (arg === "--focus") {
      const focusArg = argv[i + 1];
      if (!focusArg) {
        printUsage("Expected comma-delimited names after --focus");
        return null;
      }
      focusNames.push(...focusArg.split(","));
      i += 1;
      continue;
    }
    if (arg === "--kind") {
      const kindArg = argv[i + 1];
      if (!kindArg) {
        printUsage("Expected comma-delimited kinds after --kind");
        return null;
      }
      for (const kind of kindArg.split(",").map((value) => value.trim())) {
        if (!isDiagramKind(kind)) {
          printUsage(`Unsupported diagram kind '${kind}'`);
          return null;
        }
        kinds.push(kind);
      }
      i += 1;
      continue;
    }
    if (arg === "--strict") {
      strict = true;
      continue;
    }
    if (arg === "--reverse-links") {
      reverseLinks = true;
      continue;
    }
    if (arg === "--constraint-labels") {
      constraintLabels = true;
      continue;
    }
    if (arg === "--split") {
      const splitArg = argv[i + 1];
      if (splitArg !== "module") {
        printUsage("Expected --split module");
        return null;
      }
      split = splitArg;
      i += 1;
      continue;
    }
    if (arg === "--help" || arg === "-h") {
      printUsage();
      return null;
    }
    inputs.push(arg);
  }

  if (inputs.length === 0) {
    printUsage("Provide at least one file, directory, or glob.");
    return null;
  }

  return {
    format,
    outputPath,
    strict,
    reverseLinks,
    constraintLabels,
    split,
    filters: {
      focusNames,
      kinds,
    },
    inputs,
  };
}

function printUsage(error?: string): void {
  if (error) {
    process.stderr.write(`${error}\n`);
  }
  process.stderr.write(
    "Usage: allium-diagram [--format d2|mermaid] [--output path] [--focus names] [--kind kinds] [--split module] [--reverse-links] [--constraint-labels] [--strict] <file|directory|glob> [...]\n",
  );
}

function writeIssues(
  diagramResults: Array<{ filePath: string; result: DiagramBuildResult }>,
): number {
  let issueCount = 0;
  for (const entry of diagramResults) {
    for (const issue of entry.result.issues) {
      issueCount += 1;
      const relPath =
        path.relative(process.cwd(), entry.filePath) || entry.filePath;
      process.stderr.write(
        `${relPath}:${issue.line + 1}:1 warning ${issue.code} ${issue.message}\n`,
      );
    }
  }
  return issueCount;
}

function writeSplitByModule(
  diagramResults: Array<{ filePath: string; result: DiagramBuildResult }>,
  parsed: ParsedArgs,
): void {
  const perModule = new Map<string, DiagramModel[]>();

  for (const entry of diagramResults) {
    const moduleNames =
      entry.result.modules.length > 0 ? entry.result.modules : ["root"];
    for (const moduleName of moduleNames) {
      const existing = perModule.get(moduleName) ?? [];
      existing.push(entry.result.model);
      perModule.set(moduleName, existing);
    }
  }

  const outputDir = path.resolve(process.cwd(), parsed.outputPath ?? "");
  fs.mkdirSync(outputDir, { recursive: true });

  const extension = parsed.format === "mermaid" ? "mmd" : "d2";
  for (const [moduleName, models] of [...perModule.entries()].sort((a, b) =>
    a[0].localeCompare(b[0]),
  )) {
    const merged = mergeModels(models);
    const augmented = augmentDiagramModel(
      merged,
      diagramResults.filter((entry) =>
        (entry.result.modules.length > 0
          ? entry.result.modules
          : ["root"]
        ).includes(moduleName),
      ),
      parsed,
    );
    const filtered = applyDiagramFilters(augmented, parsed.filters);
    const output = renderDiagram(filtered, parsed.format);
    const fileName = `${sanitizePathToken(moduleName)}.${extension}`;
    const filePath = path.join(outputDir, fileName);
    fs.writeFileSync(filePath, output, "utf8");
    process.stdout.write(`Wrote ${parsed.format} diagram to ${filePath}\n`);
  }
}

function augmentDiagramModel(
  model: DiagramModel,
  diagramResults: Array<{ filePath: string; result: DiagramBuildResult }>,
  parsed: Pick<ParsedArgs, "reverseLinks" | "constraintLabels">,
): DiagramModel {
  let next = model;
  if (parsed.reverseLinks) {
    next = withReverseLinks(next);
  }
  if (parsed.constraintLabels) {
    next = withConstraintLabels(next, diagramResults);
  }
  return next;
}

function withReverseLinks(model: DiagramModel): DiagramModel {
  const edges = [...model.edges];
  const seen = new Set(
    edges.map((edge) => `${edge.from}|${edge.to}|${edge.label}`),
  );
  for (const edge of model.edges) {
    const reverse = {
      from: edge.to,
      to: edge.from,
      label: `reverse:${edge.label}`,
    };
    const key = `${reverse.from}|${reverse.to}|${reverse.label}`;
    if (!seen.has(key)) {
      seen.add(key);
      edges.push(reverse);
    }
  }
  return { nodes: model.nodes, edges };
}

function withConstraintLabels(
  model: DiagramModel,
  diagramResults: Array<{ filePath: string; result: DiagramBuildResult }>,
): DiagramModel {
  const requiresByRule = new Map<string, string>();
  for (const entry of diagramResults) {
    const text = fs.readFileSync(entry.filePath, "utf8");
    const pattern =
      /^\s*rule\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*?)^\s*\}/gm;
    for (let match = pattern.exec(text); match; match = pattern.exec(text)) {
      const requiresMatch = match[2].match(/^\s*requires\s*:\s*(.+)$/m);
      if (requiresMatch) {
        requiresByRule.set(match[1], requiresMatch[1].trim());
      }
    }
  }
  const edges = model.edges.map((edge) => {
    if (edge.label !== "when") {
      return edge;
    }
    const ruleName = edge.to.replace(/^rule_/, "");
    const constraint = requiresByRule.get(ruleName);
    if (!constraint) {
      return edge;
    }
    return { ...edge, label: `when [${constraint}]` };
  });
  return { nodes: model.nodes, edges };
}

function buildDiagramResult(text: string): DiagramBuildResult {
  const nodes: DiagramNode[] = [];
  const edges: DiagramEdge[] = [];
  const issues: DiagramIssue[] = [];
  const nodeByKey = new Map<string, DiagramNode>();
  const lineStarts = buildLineStarts(text);

  const ensureNode = (
    kind: DiagramNodeKind,
    name: string,
    labelPrefix?: string,
  ): DiagramNode => {
    const key = `${kind}:${name}`;
    const existing = nodeByKey.get(key);
    if (existing) {
      return existing;
    }
    const id = `${kind}_${name}`.replace(/[^A-Za-z0-9_]/g, "_");
    const label = labelPrefix ? `[${labelPrefix}] ${name}` : name;
    const node: DiagramNode = { id, key, label, kind };
    nodeByKey.set(key, node);
    nodes.push(node);
    return node;
  };

  const addEdge = (from: DiagramNode, to: DiagramNode, label: string): void => {
    edges.push({ from: from.id, to: to.id, label });
  };

  const topLevelPattern =
    /^\s*(external\s+entity|entity|value|variant|rule|surface|actor|enum)\s+([A-Za-z_][A-Za-z0-9_]*)(?:\s*:\s*([A-Za-z_][A-Za-z0-9_]*))?\s*\{/gm;
  for (
    let match = topLevelPattern.exec(text);
    match;
    match = topLevelPattern.exec(text)
  ) {
    const declKind = match[1];
    const name = match[2];
    const base = match[3];

    if (declKind === "rule") {
      ensureNode("rule", name, "rule");
      continue;
    }
    if (declKind === "surface") {
      ensureNode("surface", name, "surface");
      continue;
    }
    if (declKind === "actor") {
      ensureNode("actor", name, "actor");
      continue;
    }
    if (declKind === "enum") {
      ensureNode("enum", name, "enum");
      continue;
    }
    if (declKind === "value") {
      ensureNode("value", name, "value");
      continue;
    }
    if (declKind === "variant") {
      const variant = ensureNode("variant", name, "variant");
      if (base) {
        const baseEntity = ensureNode("entity", base, "entity");
        addEdge(variant, baseEntity, "extends");
      }
      continue;
    }
    ensureNode(
      "entity",
      name,
      declKind.startsWith("external") ? "external" : "entity",
    );
  }

  const entityBlockPattern =
    /^\s*(?:external\s+)?entity\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*?)^\s*\}/gm;
  for (
    let entity = entityBlockPattern.exec(text);
    entity;
    entity = entityBlockPattern.exec(text)
  ) {
    const source = ensureNode("entity", entity[1], "entity");
    const body = entity[2];
    const relPattern =
      /^\s*[A-Za-z_][A-Za-z0-9_]*\s*:\s*([A-Za-z_][A-Za-z0-9_]*(?:\/[A-Za-z_][A-Za-z0-9_]*)?)\s+for\s+this\s+[A-Za-z_][A-Za-z0-9_]*\s*$/gm;
    for (let rel = relPattern.exec(body); rel; rel = relPattern.exec(body)) {
      const targetType = rel[1].includes("/") ? rel[1].split("/")[1] : rel[1];
      const target = ensureNode("entity", targetType, "entity");
      addEdge(source, target, "rel");
    }
  }

  const rulePattern =
    /^\s*rule\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*?)^\s*\}/gm;
  for (let rule = rulePattern.exec(text); rule; rule = rulePattern.exec(text)) {
    const ruleNode = ensureNode("rule", rule[1], "rule");
    const body = rule[2];

    const when = body.match(/^\s*when\s*:\s*(.+)$/m);
    if (when) {
      const trigger = when[1].trim();
      const typed = trigger.match(
        /^[a-z_][a-z0-9_]*\s*:\s*([A-Za-z_][A-Za-z0-9_]*(?:\/[A-Za-z_][A-Za-z0-9_]*)?)\./,
      );
      if (typed) {
        const typeName = typed[1].includes("/")
          ? typed[1].split("/")[1]
          : typed[1];
        const entity = ensureNode("entity", typeName, "entity");
        addEdge(entity, ruleNode, "when");
      }

      const callPattern = /([A-Za-z_][A-Za-z0-9_]*)\s*\(/g;
      for (
        let call = callPattern.exec(trigger);
        call;
        call = callPattern.exec(trigger)
      ) {
        const triggerNode = ensureNode("trigger", call[1], "trigger");
        addEdge(triggerNode, ruleNode, "when");
      }
    }

    const createPattern =
      /\b([A-Za-z_][A-Za-z0-9_]*(?:\/[A-Za-z_][A-Za-z0-9_]*)?)\.created\s*\(/g;
    for (
      let create = createPattern.exec(body);
      create;
      create = createPattern.exec(body)
    ) {
      const raw = create[1];
      const typeName = raw.includes("/") ? raw.split("/")[1] : raw;
      const target = ensureNode("entity", typeName, "entity");
      addEdge(ruleNode, target, "ensures");
    }
  }

  const surfacePattern =
    /^\s*surface\s+([A-Za-z_][A-Za-z0-9_]*)\s*\{([\s\S]*?)^\s*\}/gm;
  for (
    let surface = surfacePattern.exec(text);
    surface;
    surface = surfacePattern.exec(text)
  ) {
    const surfaceNode = ensureNode("surface", surface[1], "surface");
    const body = surface[2];

    const forMatch = body.match(
      /^\s*for\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*([A-Za-z_][A-Za-z0-9_]*)\s*$/m,
    );
    if (forMatch) {
      const actor = ensureNode("actor", forMatch[1], "actor");
      addEdge(actor, surfaceNode, "for");
    }

    const contextMatch = body.match(
      /^\s*context\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*([A-Za-z_][A-Za-z0-9_]*)\s*$/m,
    );
    if (contextMatch) {
      const contextEntity = ensureNode("entity", contextMatch[1], "entity");
      addEdge(contextEntity, surfaceNode, "context");
    }

    for (const callName of parseSurfaceProvidesCalls(body)) {
      const triggerNode = ensureNode("trigger", callName, "trigger");
      addEdge(surfaceNode, triggerNode, "provides");
    }
  }

  for (const issue of collectSkippedDeclarationIssues(text, lineStarts)) {
    issues.push(issue);
  }

  return {
    model: normalizeModel({ nodes, edges }),
    issues,
    modules: collectModuleNames(text),
  };
}

function applyDiagramFilters(
  model: DiagramModel,
  options: DiagramFilterOptions,
): DiagramModel {
  const requestedKinds = new Set(options.kinds ?? []);
  const kindFilteredNodes =
    requestedKinds.size > 0
      ? model.nodes.filter((node) => requestedKinds.has(node.kind))
      : [...model.nodes];

  const nodeById = new Map(kindFilteredNodes.map((node) => [node.id, node]));
  const kindFilteredEdges = model.edges.filter(
    (edge) => nodeById.has(edge.from) && nodeById.has(edge.to),
  );

  const focusNames = (options.focusNames ?? [])
    .map((value) => value.trim().toLowerCase())
    .filter((value) => value.length > 0);
  if (focusNames.length === 0) {
    return normalizeModel({
      nodes: kindFilteredNodes,
      edges: kindFilteredEdges,
    });
  }

  const focusMatches = new Set<string>();
  for (const node of kindFilteredNodes) {
    const target = `${node.key} ${node.label}`.toLowerCase();
    if (focusNames.some((focus) => target.includes(focus))) {
      focusMatches.add(node.id);
    }
  }

  if (focusMatches.size === 0) {
    return { nodes: [], edges: [] };
  }

  const visible = new Set<string>(focusMatches);
  for (const edge of kindFilteredEdges) {
    if (focusMatches.has(edge.from) || focusMatches.has(edge.to)) {
      visible.add(edge.from);
      visible.add(edge.to);
    }
  }

  return normalizeModel({
    nodes: kindFilteredNodes.filter((node) => visible.has(node.id)),
    edges: kindFilteredEdges.filter(
      (edge) => visible.has(edge.from) && visible.has(edge.to),
    ),
  });
}

function renderDiagram(model: DiagramModel, format: DiagramFormat): string {
  if (format === "mermaid") {
    return renderMermaid(model);
  }
  return renderD2(model);
}

function renderD2(model: DiagramModel): string {
  const lines: string[] = ["direction: right", ""];
  const nodesByKind = groupNodesByKind(model.nodes);
  for (const [kind, nodes] of nodesByKind) {
    lines.push(`${kind}_group: {`);
    lines.push(`  label: "${escapeD2(kindLabel(kind))}"`);
    lines.push("  style: {");
    lines.push('    stroke: "#7b8794"');
    lines.push('    fill: "#f8fafc"');
    lines.push("  }");
    for (const node of nodes) {
      lines.push(`  ${node.id}: "${escapeD2(node.label)}"`);
    }
    lines.push("}");
    lines.push("");
  }

  for (const edge of model.edges) {
    lines.push(`${edge.from} -> ${edge.to}: "${escapeD2(edge.label)}"`);
  }
  return `${lines.join("\n").replace(/\n+$/g, "")}\n`;
}

function renderMermaid(model: DiagramModel): string {
  const lines: string[] = ["flowchart LR"];
  const nodesByKind = groupNodesByKind(model.nodes);
  for (const [kind, nodes] of nodesByKind) {
    lines.push(`  subgraph ${kind}_group["${escapeMermaid(kindLabel(kind))}"]`);
    for (const node of nodes) {
      lines.push(`    ${node.id}["${escapeMermaid(node.label)}"]`);
    }
    lines.push("  end");
  }
  for (const edge of model.edges) {
    lines.push(`  ${edge.from} -->|${escapeMermaid(edge.label)}| ${edge.to}`);
  }
  return `${lines.join("\n")}\n`;
}

function groupNodesByKind(
  nodes: DiagramNode[],
): Map<DiagramNodeKind, DiagramNode[]> {
  const grouped = new Map<DiagramNodeKind, DiagramNode[]>();
  const order: DiagramNodeKind[] = [
    "entity",
    "variant",
    "value",
    "enum",
    "rule",
    "surface",
    "actor",
    "trigger",
  ];
  for (const kind of order) {
    grouped.set(kind, []);
  }
  for (const node of nodes) {
    grouped.get(node.kind)?.push(node);
  }

  const sortedEntries: Array<[DiagramNodeKind, DiagramNode[]]> = [];
  for (const [kind, items] of grouped.entries()) {
    const sorted = [...items].sort((a, b) => a.id.localeCompare(b.id));
    if (sorted.length > 0) {
      sortedEntries.push([kind, sorted]);
    }
  }
  return new Map(sortedEntries);
}

function kindLabel(kind: DiagramNodeKind): string {
  if (kind === "entity") {
    return "Entities";
  }
  if (kind === "variant") {
    return "Variants";
  }
  if (kind === "value") {
    return "Values";
  }
  if (kind === "enum") {
    return "Enums";
  }
  if (kind === "rule") {
    return "Rules";
  }
  if (kind === "surface") {
    return "Surfaces";
  }
  if (kind === "actor") {
    return "Actors";
  }
  return "Triggers";
}

function normalizeModel(model: DiagramModel): DiagramModel {
  const uniqueNodes = new Map<string, DiagramNode>();
  for (const node of model.nodes) {
    uniqueNodes.set(node.id, node);
  }

  const uniqueEdges = new Map<string, DiagramEdge>();
  for (const edge of model.edges) {
    uniqueEdges.set(`${edge.from}|${edge.to}|${edge.label}`, edge);
  }

  return {
    nodes: [...uniqueNodes.values()].sort((a, b) => a.id.localeCompare(b.id)),
    edges: [...uniqueEdges.values()].sort((a, b) =>
      `${a.from}|${a.to}|${a.label}`.localeCompare(
        `${b.from}|${b.to}|${b.label}`,
      ),
    ),
  };
}

function isDiagramKind(value: string): value is DiagramNodeKind {
  return (
    value === "entity" ||
    value === "value" ||
    value === "variant" ||
    value === "rule" ||
    value === "surface" ||
    value === "actor" ||
    value === "enum" ||
    value === "trigger"
  );
}

function sanitizePathToken(value: string): string {
  return value.replace(/[^A-Za-z0-9_-]/g, "-");
}

function mergeModels(models: DiagramModel[]): DiagramModel {
  const nodes = new Map<string, DiagramModel["nodes"][number]>();
  const edges = new Map<string, DiagramModel["edges"][number]>();

  for (const model of models) {
    for (const node of model.nodes) {
      nodes.set(node.id, node);
    }
    for (const edge of model.edges) {
      edges.set(`${edge.from}|${edge.to}|${edge.label}`, edge);
    }
  }

  return {
    nodes: [...nodes.values()].sort((a, b) => a.id.localeCompare(b.id)),
    edges: [...edges.values()].sort((a, b) =>
      `${a.from}|${a.to}|${a.label}`.localeCompare(
        `${b.from}|${b.to}|${b.label}`,
      ),
    ),
  };
}

function resolveInputs(inputs: string[]): string[] {
  const files = new Set<string>();
  const cwd = process.cwd();
  let recursiveCache: string[] | null = null;

  for (const input of inputs) {
    const resolved = path.resolve(cwd, input);
    if (fs.existsSync(resolved)) {
      const stat = fs.statSync(resolved);
      if (stat.isDirectory()) {
        for (const filePath of walkAlliumFiles(resolved)) {
          files.add(filePath);
        }
      } else if (stat.isFile() && resolved.endsWith(".allium")) {
        files.add(resolved);
      }
      continue;
    }

    if (recursiveCache === null) {
      recursiveCache = walkAllFiles(cwd);
    }

    const matcher = wildcardToRegex(input);
    for (const candidate of recursiveCache) {
      const relative = path.relative(cwd, candidate).split(path.sep).join("/");
      if (matcher.test(relative) && candidate.endsWith(".allium")) {
        files.add(candidate);
      }
    }
  }

  return [...files].sort();
}

function walkAlliumFiles(root: string): string[] {
  return walkAllFiles(root).filter((entry) => entry.endsWith(".allium"));
}

function walkAllFiles(root: string): string[] {
  const out: string[] = [];
  const stack = [root];

  while (stack.length > 0) {
    const current = stack.pop();
    if (!current) {
      continue;
    }

    const entries = fs.readdirSync(current, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        stack.push(fullPath);
      } else if (entry.isFile()) {
        out.push(fullPath);
      }
    }
  }

  return out;
}

function wildcardToRegex(pattern: string): RegExp {
  const escaped = pattern
    .split(path.sep)
    .join("/")
    .replace(/[.+^${}()|[\]\\]/g, "\\$&")
    .replace(/\*/g, ".*")
    .replace(/\?/g, ".");

  return new RegExp(`^${escaped}$`);
}

function collectModuleNames(text: string): string[] {
  const modules = new Set<string>();
  const pattern = /^\s*module\s+([a-z_][a-z0-9_]*)\b/gm;
  for (let match = pattern.exec(text); match; match = pattern.exec(text)) {
    modules.add(match[1]);
  }
  return [...modules].sort();
}

function collectSkippedDeclarationIssues(
  text: string,
  lineStarts: number[],
): DiagramIssue[] {
  const issues: DiagramIssue[] = [];
  const pattern =
    /^\s*(default|deferred|open_question|context|config|use)\b[^\n]*$/gm;
  for (let match = pattern.exec(text); match; match = pattern.exec(text)) {
    if (isCommentLineAtIndex(text, match.index)) {
      continue;
    }
    issues.push({
      code: "allium.diagram.skippedDeclaration",
      line: offsetToLine(lineStarts, match.index),
      message: `Diagram extraction skipped '${match[1]}' declaration at line ${offsetToLine(lineStarts, match.index) + 1}.`,
    });
  }
  return issues;
}

function buildLineStarts(text: string): number[] {
  const starts = [0];
  for (let i = 0; i < text.length; i += 1) {
    if (text[i] === "\n") {
      starts.push(i + 1);
    }
  }
  return starts;
}

function offsetToLine(lineStarts: number[], offset: number): number {
  let line = 0;
  for (let i = 0; i < lineStarts.length; i += 1) {
    if (lineStarts[i] > offset) {
      break;
    }
    line = i;
  }
  return line;
}

function isCommentLineAtIndex(text: string, index: number): boolean {
  const lineStart = text.lastIndexOf("\n", index) + 1;
  const lineEnd = text.indexOf("\n", index);
  const line = text.slice(lineStart, lineEnd >= 0 ? lineEnd : text.length);
  return /^\s*--/.test(line);
}

function escapeD2(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function escapeMermaid(value: string): string {
  return value.replace(/"/g, "'");
}

function parseSurfaceProvidesCalls(body: string): string[] {
  const calls: string[] = [];
  const sectionPattern = /^(\s*)provides\s*:\s*$/gm;
  for (
    let section = sectionPattern.exec(body);
    section;
    section = sectionPattern.exec(body)
  ) {
    const baseIndent = (section[1] ?? "").length;
    let cursor = section.index + section[0].length + 1;
    while (cursor < body.length) {
      const lineEnd = body.indexOf("\n", cursor);
      const end = lineEnd >= 0 ? lineEnd : body.length;
      const line = body.slice(cursor, end);
      const trimmed = line.trim();
      const indent = (line.match(/^\s*/) ?? [""])[0].length;
      if (trimmed.length === 0) {
        cursor = end + 1;
        continue;
      }
      if (indent <= baseIndent) {
        break;
      }
      const match = line.match(/([A-Za-z_][A-Za-z0-9_]*)\s*\(/);
      if (match) {
        calls.push(match[1]);
      }
      cursor = end + 1;
    }
  }
  return calls;
}

const exitCode = main(process.argv.slice(2));
process.exitCode = exitCode;
